# sar 命令详解

sar是System Activity Reporter（系统活动情况报告）的缩写。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据；取样数据和分析的结果都可以存入文件，所需的负载很小。sar是目前Linux上最为全面的系统性能分析工具之一，可以从14个大方面对系统的活动进行报告，包括文件的读写情况、系统调用的使用情况、串口、CPU效率、内存使用状况、进程活动及IPC有关的活动等，使用也是较为复杂。

sar是查看操作系统报告指标的各种工具中，最为普遍和方便的；它有两种用法；

1. 追溯过去的统计数据（默认）
2. 周期性的查看当前数据



## 相关文件 

`/etc/sysconfig/sysstat` 是配置，`/var/log/sa`是储存统计数据的地方，默认储存一个月的，一天一个文件，文件中有24小时的数据。



## 使用方法

Usage: sar [ options ] [ <interval> [ <count> ] ]



#### 选项

- -B 分页统计



## 分页统计

```
$ sudo sar -B
11:00:01 AM  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s pgsteal/s    %vmeff
11:10:01 AM      2.03   3607.65  71692.69      2.46  52217.31      0.00      0.00      0.00      0.00
11:20:01 AM      0.00   2581.87  69660.71      2.34  51527.05      0.00      0.00      0.00      0.00
11:30:01 AM      0.03   3133.09  70731.26      2.38  52319.47      0.00      0.00      0.00      0.00
11:40:02 AM      0.06   4657.76  71093.80      2.14  53488.74      0.00      0.00      0.00      0.00
11:50:01 AM     27.58   4398.13  70583.10      2.24  52897.79      0.00      0.00      0.00      0.00
12:00:01 PM      0.37   3209.40  71278.17      2.25  52764.36      0.00      0.00      0.00      0.00
12:10:01 PM   1791.07   7004.83  72407.94      2.69  54012.09      0.00      0.00      0.00      0.00
12:20:01 PM      0.11   5210.17  70653.57      2.44  52958.06      0.00      0.00      0.00      0.00
12:30:01 PM      0.11   4626.54  70084.51      2.14  52262.60      0.00      0.00      0.00      0.00
12:40:01 PM      0.16   4981.73  72656.71      2.00  52870.70      0.00      0.00      0.00      0.00
12:50:01 PM    266.87   6141.89  72094.90      2.26  53977.91      0.00      0.00      0.00      0.00
01:00:01 PM      0.24   5113.39  71358.22      2.45  53009.57      0.00      0.00      0.00      0.00
01:10:01 PM      2.03   4596.51  72666.33      2.63  52910.50      0.00      0.00      0.00      0.00
01:20:01 PM      1.52   6023.10  74710.75      2.34  54503.86      0.00      0.00      0.00      0.00
01:30:01 PM      0.00   4068.47  71139.03      2.24  52225.24      0.00      0.00      0.00      0.00
01:40:02 PM      0.37   3002.31  70453.83      2.17  51802.84      0.00      0.00      0.00      0.00
01:50:01 PM      0.00   4055.24  71599.26      2.27  52253.44      0.00      0.00      0.00      0.00
02:00:01 PM      0.00   3728.87  70593.02      2.32  51766.70      0.00      0.00      0.00      0.00
Average:        70.66   3916.90  71392.35      2.33  52780.81      0.00      0.00      0.00      0.00
```

- pgpgin/s：表示每秒从磁盘或SWAP置换到内存的字节数(KB) 
- pgpgout/s：表示每秒从内存置换到磁盘或SWAP的字节数(KB) 
- fault/s：每秒钟系统产生的缺页数，即主缺页与次缺页之和(major + minor) 
- majflt/s：每秒钟产生的主缺页数 
- pgfree/s：每秒被放入空闲队列中的页个数 
- pgscank/s：每秒被 kswapd 扫描的页个数 
- pgscand/s：每秒直接被扫描的页个数 
- pgsteal/s：每秒钟从 cache 中被清除来满足内存需要的页个数 
- %vmeff：每秒清除的页(pgsteal)占总扫描页(pgscank + pgscand)的百分比

> 内存缺页，参考：https://liam.page/2017/09/01/page-fault/
>
> CPU 不能直接和硬盘进行交互。CPU 所作的一切运算，都是通过 CPU 缓存间接与内存进行操作的。若是 CPU 请求的内存数据在物理内存中不存在，那么 CPU 就会报告「缺页错误（Page Fault）」，提示内核。
>
> 因为 CPU 无法继续进行进程请求的计算，并报告了缺页错误，用户进程必然就中断了。这样的中断称之为缺页中断。在报告 Page Fault 之后，进程会从用户态切换到系统态，交由操作系统内核的 Page Fault Handler 处理缺页错误。
>
> 在内核处理缺页错误时，就有可能进行磁盘的读写操作。这样的操作，相对 CPU 的处理是非常缓慢的。因此，发生大量的缺页错误，势必会对程序的性能造成很大影响。因此，在对性能要求很高的环境下，应当尽可能避免这种情况。
>
> 
>
> 硬缺页错误与软缺页错误
>
> 缺页错误可以分为两类：硬缺页错误（Hard Page Fault）和软缺页错误（Soft Page Fault）。这里，前者又称为主要缺页错误（Major Page Fault）；后者又称为次要缺页错误（Minor Page Fault）。当缺页中断发生后，Page Fault Handler 会判断缺页的类型，进而处理缺页错误，最终将控制权交给用户态代码。
>
> 若是此时物理内存里，已经有一个页帧正是此时 CPU 请求的内存页，那么这是一个软缺页错误；于是，Page Fault Hander 会指示 MMU 建立相应的页帧到页的映射关系。这一操作的实质是进程间共享内存——比如动态库（共享对象），比如 `mmap` 的文件。
>
> 若是此时物理内存中，没有相应的页帧，那么这就是一个硬缺页错误；于是 Page Fault Hander 会指示 CPU，从已经打开的磁盘文件中读取相应的内容到物理内存，而后交由 MMU 建立这份页帧到页的映射关系。
>
> 不难发现，软缺页错误只是在内核态里轻轻地走了一遭，而硬缺页错误则涉及到磁盘 I/O。因此，处理起来，硬缺页错误要比软缺页错误耗时长得多。这就是为什么我们要求高性能程序必须在对外提供服务时，尽可能少地发生硬缺页错误。















