# 用户态与内核态

Linux 系统的空间被分成内核空间和用户空间，执行级别也分为用户态和内核态，且两个空间彼此隔离。

用户进程只能访问自己的空间，它不能读取和修改内核空间的数据，也不能执行内核空间的代码。

CPU 大部分时间都在执行用户空间的代码，也尽量应该让 CPU 运行用户态的代码。



## 系统调用

如果用户进程想要执行某些影响整个系统的操作（比如操作IO设备），它就要通过系统调用向内核发出请求。如果内核确认其有权这么做，会代表用户进程 完成相关操作。在此期间，内核可以访问用户进程的地址空间。系统调用完成后再返回用户态。



## 中断

除了系统调用之外，还有一种内核态的使用是中断事件，它是一种信号，发送者可以是硬件，也可以是软件。



## 上下文切换

除了系统调用和中断处理，抢占式多任务也是消耗内核态资源的主要因素，现代程序都是讲究高并发的，并发是伪并行。

CPU 时间被切分为无数细小的时间片，分发给所有进程，根据进程重要程度，其所获取的时间片大小叶不尽相同。

每个进程依靠时间片来获取CPU的计算处理服务。当时间片花完，内核会从进程收回控制权，转而服务另一个进程。而当前进程的运行时环境（CPU寄存器和页表等内容）都会被保存起来，等到该进程在下轮执行时，再将它的运行时环境复原。这样一个进程切换的过程被称为上下文切换（Context Switch）。

在一个进程超多的系统环境中，上下文切换会非常频繁，这意味着时间片被大量损耗，尤其在进程游走于多个核心之间的时候，这种跨核心切换对系统性能负载影响更大。

使用 vmstat 命令查看上下文切换数量：

```
$ vmstat 1 3
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
13  1 251648 20669048   1036 80835904    0    0  1300   282    0    0 19  6 74  1  0
 8  0 251648 20656740   1036 80855072    0    0     0 226766 88956 142889 22 10 67  2  0
10  0 251648 20599216   1036 80917840    0    0 19328 45345 88058 156199 23 10 63  4  0
```

其中 cs 就是上下文切换次数。





















