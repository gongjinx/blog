# 进程调度

当一个进程创建时，它获得一个父进程地址空间的副本。共享正文段(代码段)，但并不执行一个父进程数据段、栈和堆的完全拷贝，而是采用写时复制技术。

linux内核的三种调度方法：

- SCHED_OTHER 分时调度策略，

- SCHED_FIFO 实时调度策略，先到先服务，没有时间片，运行任意时间，直到执行完毕或被高优先级的进程插队

- SCHED_RR 实时调度策略，按优先级进行时间片轮转

> 实时进程将得到优先调用，实时进程根据实时优先级决定调度权值，分时进程则通过nice和counter值决定权值，nice越小，counter越大，被调度的概率越大，也就是曾经使用了cpu最少的进程将会得到优先调度。

进程大体上分为实时进程和非实时进程，比如音频播放就是典型的实时进程，实时进程的调度策略分为 SCHED_FIFI 和 SCHED_RR。

实时调度适合那些进程数少，且延迟影响严重的场景。使用实时调度的最佳实践是从较低的优先级开始，然后根据实际情况提升优先级，切不可直接将优先级调至最高，以防系统内部的关键进程阻塞在后面无法执行。

只要系统中有实时进程在运行，它总是优先于非实时进程。所以在使用实时调度前，需将它们隔离到特定的核心上去，绑定核心时最好从后向前分配，不要让实时调度策略影响到所有核心，以防止造成阻塞。

如果多个进程需要设置成 SCHED_FIFO，在设置优先级时，要考虑他们是否有依赖关系。优先级会影响执行顺序！！！！

实时优先级的取值范围时 1-99，优先级操作方法：

```bash
$ sudo chrt -p 1226
# 启动时设置优先级，其中 -f 是 SCHED_FIFO,-r 是 SCHED_RR
$ sudo chrt -f [1-99] <COMMAND>
$ sudo chrt -r [1-99] <COMMAND>
# 调整优先级
$ sudo chrt -p -r [1-99] <PID>
$ sudo chrt -p -r [1-99] <PID>
```



#### 分时调度

在 Linux 服务器中，大部分守护进程都是分时调度，他们的调度类型都是 SCHED_OUTER。

SCHED_OTHER只能在静态优先级为0时使用*(普通线程)*。SCHED_OTHER是标准的Linux分时调度策略(不需要实时机制)。

如何从静态优先级为0的列表中选择运行的线程取决于列表中的`dynamic`优先级。`dynamic`优先级基于nice值，且在每次线程准备运行时增加。这种机制保证公平处理所有的SCHED_OTHER线程。

在Linux内核源码中，SCHED_OTHER被称为SCHED_NORMAL。

> 在 top 命令中，NI 的值就是 NICE 值。
>
> NICE值为-20到+19，普通进程默认为 0。
>
> NICE 值越高，说明它越高尚，愿意把自己的时间奉献给别人。
>
> 系统中重要的进程 NICE 值会为 -20。

设置 NICE 值的命令：

```bash
$ nice -n [-20-19] <COMMAND>
$ renice [-20-19] <PID>
```

