# 缓存层

官方文档：https://ceph.readthedocs.io/en/latest/rados/operations/cache-tiering/

缓存层为 Ceph 客户端提供了更好的 I/O 性能，用于存储在后备存储层中的部分数据。

缓存分层涉及创建配置为充当缓存层的相对较快/昂贵的存储设备（例如，固态驱动器）的池，以及配置为充当经济存储的擦除编码或相对较慢/更便宜的设备的后备池 层。Ceph反对者处理放置对象的位置，并且分层代理确定何时将对象从缓存刷新到后备存储层。因此，缓存层和后备存储层对Ceph客户端是完全透明的。

缓存分层代理自动处理缓存层和后备存储层之间的数据迁移。但是，管理员可以通过设置缓存模式来配置此迁移的方式。主要有两种方案：

- **writeback** mode: 当管理员使用 `writeback` 模式配置层时，Ceph客户端将数据写入缓存层并从缓存层接收ACK。随着时间的流逝，写入缓存层的数据将迁移到存储层，并从缓存层中清除。从概念上讲，缓存层覆盖在后备存储层的“前面”。当Ceph客户端需要驻留在存储层中的数据时，缓存分层代理在读取时将数据迁移到缓存层，然后将其发送到Ceph客户端。之后，Ceph客户端可以使用缓存层执行 I/O，直到数据变为非活动状态为止。这是可变数据的理想选择（例如，照片/视频编辑，交易数据等）。
- **readproxy** mode: 此模式将使用高速缓存层中已经存在的任何对象，但是如果高速缓存中不存在对象，则请求将被代理到基本层。这对于从写回模式过渡到禁用的缓存非常有用，因为它允许在清空缓存时工作负载能够正常运行，而无需向缓存中添加任何新对象。

其他模式还有：

- **readonly** 仅在读取操作时将对象提升到缓存；写操作将转发到基本层。此模式适用于不需要一致性的只读工作负载，存储系统无需强制执行该工作负载。（警告：当在基础层中更新对象时，Ceph不会尝试将这些更新同步到缓存中的相应对象。由于此模式被认为是实验性的，因此必须通过--yes-i-really-mean-it选项才能启用它。）
- **none** 用于完全禁用缓存。



## 告诫

缓存分层将降低大多数工作负载的性能。用户在使用此功能之前应格外小心。

- 取决于工作量：缓存是否会提高性能在很大程度上取决于工作负载。由于将对象移入或移出缓存会产生一定的成本，因此只有在数据集的访问模式存在较大的偏斜（大多数请求都接触少量对象）时，此方法才有效。缓存池应足够大，以捕获您的工作负载的工作集，以免发生抖动。
- 难以进行基准测试：用户用来衡量性能的大多数基准测试都会对缓存分层显示出糟糕的性能，部分原因是因为其中很少有人将请求偏向一小部分对象，因此缓存“预热”可能需要很长时间，并且因为 预热成本可能很高。
- 通常较慢：对于不支持缓存分层的工作负载，性能通常会比未启用缓存分层的普通RADOS池慢。
- librados对象枚举：在存在案例的情况下，librados级对象枚举API并不意味着是一致的。如果您的应用程序直接使用librados并依赖于对象枚举，则缓存分层可能无法按预期工作。 （对于RGW，RBD或CephFS，这不是问题。）
- 复杂：启用缓存分层意味着在RADOS群集中使用了许多其他机制和复杂性。这增加了您在系统中遇到其他用户尚未遇到的错误的可能性，并使您的部署面临更高的风险。

























